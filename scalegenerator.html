<html>
<head>
    <title>Scale Generator</title>
    <style type="text/css">
        body {
            text-align: center;
        }
        #Results {
            font-family: Consolas;
        }
        debug {
            background-color: #F2AEAE;
        }
        log {
            background-color: #C0E2FF;
        }
    </style>
</head>
<body>
<div id="ControlPanel">
    <input type="checkbox" id="ControlPanel_Debug"           >Debug                     </input><br><br>
    <input type="checkbox" id="ControlPanel_SemiSemi"        >Allow subsequent semitones</input><br><br>
    <select id="ControlPanel_RootNote">
        <option value="C" >C </option>
        <option value="C#">C&sharp;</option>
        <option value="D" >D </option>
        <option value="D#">D&sharp;</option>
        <option value="E" >E </option>
        <option value="F" >F </option>
        <option value="F#">F&sharp;</option>
        <option value="G" >G </option>
        <option value="G#">G&sharp;</option>
        <option value="A" >A </option>
        <option value="A#">A&sharp;s</option>
        <option value="B" >B </option>
    </select>Root Note<br><br>
    <button id="ControlPanel_Btn" onclick="main()">Generate Scale</button>
</div>
<br><hr><br>
<div id="Results">

</div>

</body>
</html>
<script src="https://code.jquery.com/jquery-3.6.0.slim.min.js" integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
<script type="text/javascript">

// ##### DECL

function clearOutput() {
    Results.innerText = "";
}

function log(msg, debug = false) {
    if(debug && !ControlPanel_Debug.checked) {
        return;
    }
    var elemToAppend = document.createElement(debug? "debug" : "log");
    elemToAppend.innerText = msg;
    Results.appendChild(elemToAppend);
    Results.appendChild(document.createElement('br'));
}

function debug(msg) {
    log(msg, true);
}

function print(msg) {
    log(msg);
}

function arrToString(arr) {
    return arr.toLocaleString()
              .replaceAll(",",", ")
              .replaceAll("#","♯")
              .replaceAll("b","♭");
}

function getRandomInt(min, max) {
    var max = max + 1; // more convenient to make both `min` and `max` inclusive
    var min = Math.ceil(min);
    var max = Math.floor(max);
    return Math.floor(Math.random() * (max - min) + min);
}

function safeSumList(listToSum) {
    if(listToSum == undefined ||  listToSum == null || listToSum.length == 0) {
        return 0;
    }
    return listToSum.reduce((x,sum)=>sum+x);
}

function getIntervalBySemitonalWidth(minSemitones, maxSemitones) {
    return getRandomInt(minSemitones, maxSemitones) * 0.5;
}

function generateScaleIntervals(allowConsecutiveSemitones) {
    var intervalArr = Array();
    var lastInterval = 0;
    var shouldContinue = true;
    var intervalToPush = -1;

    while(shouldContinue) {
        var intervalSum = safeSumList(intervalArr);
        var tonesMuchLeft = 6 - intervalSum;
        debug("Tones left ["+tonesMuchLeft+"]");

        switch(tonesMuchLeft) {
            case 0  : {
                debug("Octave complete");
                shouldContinue = false;
                break;
            }
            case 0.5: {
                debug("Only 0.5 semitones left - adding that");
                intervalToPush = 0.5;
                break;
            }
            case 1  : {
                if(lastInterval == 0.5) {
                    debug("Only 1 semitone left, and last one was a semitone");
                    intervalToPush = !allowConsecutiveSemitones ? 1 : getIntervalBySemitonalWidth(1,2);
                } else {
                    if(allowConsecutiveSemitones) {
                        intervalToPush = getIntervalBySemitonalWidth(1,2);
                    } else {
                        intervalToPush = 1;
                    }
                }
                break;
            }
            default : {
                if(lastInterval == 0.5 && !allowConsecutiveSemitones) {
                    debug("Last interval was a semitone and no consequitves are allowed - enforcing");
                    intervalToPush = getIntervalBySemitonalWidth(2,3);
                } else {
                    intervalToPush = getIntervalBySemitonalWidth(1,3);
                }
                break;
            }
        }

        if (shouldContinue) {
            debug("Adding ["+intervalToPush+"]");
            intervalArr.push(intervalToPush);
            lastInterval = intervalToPush;
        }
    }

    return intervalArr;
}

function nameNotCorrectly(pallet, nextIdx, lastNote) {
    var nextNote = pallet[nextIdx];
    if(/* ControlPanel_SemiSemi.checked || */ lastNote.charAt(0) != nextNote.charAt(0)) {
        return nextNote;
    }
    debug("Avoiding bad note naming - lastNote ["+lastNote+"] would-be nextNote ["+nextNote+"]");
    var candidate = pallet[nextIdx + 1].charAt(0) + "b";
    if(candidate != lastNote) {
        return candidate;
    }
    debug("New candidate ["+candidate+"] matches previous note ["+lastNote+"] - resulting to double flats");
    return pallet[nextIdx + 2].charAt(0) + "bb";
}

function intervalsToNotes(intervalArr, startingNote) {
    const NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", /* looping */ "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", /* looping */ "C", "C#", "D", "D#", "E" ];
    var notePalletToUse = NOTES.slice(NOTES.indexOf(startingNote), NOTES.length);
    var notesToReturn = [ notePalletToUse[0] ];

    var positionInPallet = 0;
    var lastNoteAdded = notePalletToUse[positionInPallet];
    intervalArr.forEach(interval => {
        var steps = interval / 0.5;
        positionInPallet += steps;
        var noteToAdd = nameNotCorrectly(notePalletToUse, positionInPallet, lastNoteAdded);
        notesToReturn.push(noteToAdd);
        lastNoteAdded = noteToAdd;
    });

    if(!ControlPanel_Debug.checked) {
        notesToReturn.pop(); // drop the duplicate octave if not debugging
    }
    return notesToReturn;
}

// no objects allowed
function simpleArraysEqual(arr1, arr2) {
    return JSON.stringify(arr1) == JSON.stringify(arr2);
}

function rotateArr(arr) {
    var firstElem = arr[0];
    var toReturn = arr.slice(1, arr.length);
    toReturn.push(firstElem);
    return toReturn;
}

function nameScale(rootNote, scaleIntervals) {    
    const SCALES_BANK = {
        // "Pentatonic Major" : [1,1,1.5,1,1.5],
        // "Natural Minor"    : [1,0.5,1,1,0.5,1,1],
        "Major"               : [1,1,0.5,1,1,1,0.5],
        "Minor Pentatonic"    : [1.5,1,1,1.5,1],
        "Harmonic Minor"      : [1,0.5,1,1,1,1,0.5],
        "Melodic Minor"       : [1,0.5,1,1,0.5,1.5,0.5],
        "Whole Tone"          : [1,1,1,1,1,1],
        "Chromatic"           : [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],
        "Diminished Arpeggio" : [1.5,1.5,1.5,1.5],
        "Altered"             : [0.5,1,0.5,1,1,1,1]
    }

    for(scaleName in SCALES_BANK) {
        var activeScale = SCALES_BANK[scaleName];
        var matchedInversion = testScaleMatchWithInversions(scaleIntervals, activeScale);
        if(matchedInversion > -1) {
            return scaleName + " inversion " + matchedInversion + " in " + rootNote;
        }
    }

    return "Unknown scale";
}

function testScaleMatchWithInversions(scaleToTest, scaleToCompareTo) {
    var scaleRotated = scaleToCompareTo;
    for (var i = 0; i < scaleToCompareTo.length; ++i) {
        if(simpleArraysEqual(scaleToTest, scaleRotated)) {
            return i;
        }
        scaleRotated = rotateArr(scaleRotated);
    }
    return -1;
}

// ##### MAIN

function main() {
    clearOutput();
    debug("=== START ===");

    intervalArr = generateScaleIntervals(ControlPanel_SemiSemi.checked);
    print("Intervals [" + arrToString(intervalArr) + "]");
    debug("Sum       [" + safeSumList(intervalArr) + "]");
    debug("Count     [" + intervalArr.length       + "]");
    debug("=============");
    if(ControlPanel_SemiSemi.checked) {
        print("Warning: note-naming when allowing consequitve semitones is tricky, so this might be off");
    }
    notes = intervalsToNotes(intervalArr, ControlPanel_RootNote.value);
    print("Notes     [" + arrToString(notes)       + "]");

    debug("=============");
    scaleName = nameScale(ControlPanel_RootNote.value, intervalArr);
    print("Name      [" + scaleName                + "]");

    // debug("=============");
    // playNotes(notes);

    debug("=== FINISH ===");
    print("");
}


</script>